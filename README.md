# Rscompile

General compiler tools written in Rust for educational purposes.

# Components:
- [x] Tokenizer
- [x] Parser
- [ ] Analyzer
- [ ] Generator

# Tokenizer

Tokenizes a char sequence (`String`) using 2 states recognized using regular expressions:
1. Any number of _TOKEN_ regexes
2. One _IGNORE_ regex

Outputs `Vec<Token>`. The `Token` struct contains the original token string slice and also a `TokenTypeId` representing the Token type. The `TokenTypeId` corresponds to the index of the _TOKEN_ pattern given to the `Tokenizer` constructor. The `Token` struct also contains text position information for error messages.

_TOKEN PATTERNS_ may be _SINGLE_ or _SURROUND_ types
1. _SINGLE_: captures the whole pattern at once
2. _SURROUND_: finds the begin and end pattern, and capturing them and everything in between, with optional escape characters

General rules are:
1. _TOKENS_ can appear consecutively, or with _IGNORE_ chars in between them. _IGNORE_ chars are discarded.
2. Regex patterns are tried in the order given during the construction of the `Tokenizer` (_IGNORE_ is always tried last)

_TOKEN_ types are uniquely identified by `TokenTypeId`s, which are also used by the `Parser` in parsing the token sequence. An _EOF_ Token with a unique `TokenTypeId = -1` is also automatically added to the end of the `Token` sequence.

The given regexes must be able to handle all chars in the input to tokenize successfully (except for inner characters of SURROUND tokens). For well-defined behavior, the _IGNORE_ regex should be defined to consume all chars in between valid tokens.

A preprocessor function can also be optionally given during construction of the `Tokenizer`. The function should return a `String`, and will automatically be called on the input text when tokenize is called.


# Parser/Grammar

Table-driven, deterministic `Parser` that creates a parse tree from a sequence of tokens (such as one created by `Tokenizer`). The grammar rules can be customized prior to parsing by creating a custom `Grammar` instance. The output is a tree of connected `Node` objects, each associated to a `Gvar` (_Grammar Variable_) as defined in the grammar.

Currently only accepts _LL(k)_ unambiguous grammars for any _k_ and _LR(1)_ grammars.

`Grammar` is generated by configuring a `GrammarGenerator`, and calling `generate` to return the `Grammar`. The `Grammar` should be treated immutable once generated.

`GrammarGenerator` is configured by defining `Gvars` of _Non-Terminals_ and _Terminals_ using the `new_nonterm` or `new_term` methods, and then creating _Productions_ using `make_prod`.

Rules for Gvar Definition:
1. _Non-terminals_ must have at least 1 production
2. _Terminals_ need to be given a unique `TokenTypeId` upon creation

To begin the parse, the `Parser` is fed a `Vec<Token>` produced by `Tokenizer`.

Note: The parser needs all input tokens to be defined in the grammar, so if using the token sequence created by Tokenizer, make sure to define the `EOF` token in the Grammar definition.

### ParserLL

A top-down parser for _LL(k)_ grammars (_Left-to-right, leftmost derivation_). Compatible with _LL(k)_ grammars of any _k_ as long as the grammar is unambiguous and the lookahead does not need to go through a recursion. For example, the following grammar is incompatible:

    S -> Ay | Bz
    A -> xA | eps
    B -> xB | eps

The parser cannot tell whether to reduce the prefix sequence of `x`s to `A`s or `B`s until it reaches the `y` or `z` at the end of the whole sequence. `ParserLL` can deal with arbitrary _k_, but it needs to pre-compute the whole transition table during construction, and currently automatically computes the required lookahead from the grammar rules. In the example above, this lookahead value cannot be computed so it is incompatible with `ParserLL`, even though the grammar is obviously unambiguous.

**Example LL(2) grammar (with common prefix)**

    Program -> Expression EOF
    Expression -> Term Operator Expression
    Expression -> Term
    Term -> [0-9]+
    Operator -> [-+/*]

**Example LL(1) grammar (eliminated common prefixes from above)**

    Program -> Expression EOF
    Expression -> Term Expression_Tail
    Expression_Tail -> Operator Term Expression_Tail
    Expression_Tail -> eps
    Term -> [0-9]+
    Operator -> [-+/*]

### ParserLR

A bottom-up _LALR(1)_ (_Look Ahead, left-to-right, rightmost derivation_) Parser that can parse unambiguous _LR(1)_ grammars. Uses a parse table to select the proper action based on the current state and the next token. Internally, the possible actions are `Shift`, `Reduce` and `ShiftReduce`.

Currently only support 1 token of lookahead without recursion. The following grammar is unambiguous but incompatible:

    S -> Ay | Bz
    A -> Ax | x
    B -> Bx | x

Similar to the example for `ParserLL`, in this example, `ParserLR` cannot tell whether to reduce the prefix sequence of `x`s to `A`s or `B`s until it reaches the `y` or `z` at the end of the whole sequence. `ParserLR` cannot parse this grammar even though the grammar is obviously unambiguous. Remobing the recursion however will make the grammar compatible:

    S -> Ay | Bz
    A -> x
    B -> x

No recursion does not guarantee compatibility, however. For example, the following grammar is incompatible:

    S -> Awy | Bwz
    A -> x
    B -> x

This grammar is requires more than 1 lookahead token in order to decide whether or not the prefix `x` should be reduced to an `A` or a `B`.

**Example LR(1) grammar**

    Program -> Expression EOF
    Expression -> Expression Operator Term
    Expression -> Term
    Term -> [0-9]+
    Operator -> [-+/*]


### To Do:
- Configurable disambiguation
- More descriptive errors
- Implied EOF token
- Grammar conversion